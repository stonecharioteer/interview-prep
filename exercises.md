# Exercise List

**Progress: 59/211 exercises completed in Python (27%)**

1. Arrays: `min.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
2. Arrays: `max.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
3. Arrays: `sum.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
4. Arrays: `contains(n) (membership check).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
5. Arrays: `average.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
6. Arrays: `count_of(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
7. Linked list: `length.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
8. Linked list: `find(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
9. Linked list: `min.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
10. Linked list: `max.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
11. Linked list: `sum.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
12. Linked list: `average.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
13. Linked list: `count_of(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
14. Stack: `define using list, implement push, pop, peek, is_empty.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
15. Queue: `define using list, implement enqueue, dequeue, peek, is_empty.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
16. Recursion: `factorial(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
17. Recursion: `factorial_memo(n) (memoized version).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
18. Recursion: `sum_array (recursive, no loops).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
19. Recursion: `reverse_string (recursive).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
20. Arrays: `find_index(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
21. Arrays: `find_all_indices(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
22. Linked list: `get_kth(k) (0-based).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
23. Arrays: `reversed_copy.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
24. Linked list: `append.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
25. Stack: `valid_parentheses (balanced brackets check).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
26. Arrays: `reverse_in_place.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
27. Linked list: `prepend.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
28. Queue: `implement using two stacks.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
29. Arrays: `is_sorted.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
30. Sorting: `bubble_sort (understand swapping, in-place).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
31. Sorting: `selection_sort (find min, swap to front).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
32. Linked list: `remove_first(n).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
33. Sorting: `insertion_sort (shift and insert).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
34. Stack: `evaluate_postfix (reverse polish notation).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
35. Bits: `check if number is power of two.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
36. Bits: `count set bits (Hamming weight).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
37. Arrays: `binary_search (only after is_sorted is solid).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
38. Binary search: `find_first_occurrence (leftmost index).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
39. Binary search: `find_last_occurrence (rightmost index).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
40. Binary search: `search_insert_position.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
41. Linked list: `insert_at_index.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
42. Maps (dict): `get_or_default.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
43. Math: `gcd (Euclidean algorithm).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
44. Math: `lcm (using gcd).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
45. Trees (binary): `define Node.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
46. Arrays: `merge_sorted.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
47. Sorting: `merge_sort (divide and conquer, uses merge).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
48. Recursion: `power(base, exp) (recursive).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
49. Recursion: `power_memo(base, exp) (memoized version).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
50. Linked list: `remove_at_index.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
51. Maps (dict): `increment_count.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
52. Math: `is_prime (basic check).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
53. Trees (binary): `preorder traversal.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
54. Stack: `min_stack (get min in O(1)).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
55. Bits: `single_number (XOR trick, one unique in pairs).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
56. Arrays: `rotate_k.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
57. Linked list: `reverse (iterative).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
58. Maps (dict): `merge_counts from two dicts.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
59. Trees (binary): `inorder traversal.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
60. Heap (min): `define structure, implement insert.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
61. Arrays: `two_sum (return indices, hash map approach).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
62. Two pointers: `two_sum_sorted (sorted array, O(1) space).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
63. Linked list: `middle_node.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
64. Maps (dict): `most_common key.` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
65. Two pointers: `three_sum (find triplets summing to zero).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
66. Trees (binary): `postorder traversal.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
67. Heap (min): `extract_min.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
68. Two pointers: `container_with_most_water.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
69. Arrays: `remove_duplicates_sorted.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
70. Linked list: `detect_cycle (tortoise/hare).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
71. Maps (dict): `invert mapping (handle collisions).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
72. Trees (binary): `level-order traversal (queue-based).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
73. Heap (min): `peek and size.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
74. Trie: `define TrieNode.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
75. Arrays: `partition_by_pivot.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
76. Sorting: `quick_sort (uses partition, recursive).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
77. Monotonic stack: `next_greater_element (for each element).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
78. Linked list: `merge_sorted (two lists).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
79. Maps (dict): `first_non_repeating (return key or None).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
80. Trees (binary): `size.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
81. Heap (min): `heapify (build heap from array in O(n)).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
82. Trie: `insert word.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
83. Arrays: `sliding_window_sum(k) (fixed size).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
84. Sliding window: `max_sum_subarray_size_k.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
85. Monotonic stack: `next_smaller_element.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
86. Linked list: `nth_from_end(n).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
87. Sliding window: `longest_substring_k_distinct (variable size).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
88. Backtracking: `generate_subsets (power set).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
89. Trees (binary): `height.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
90. Heap (min): `heap_sort.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
91. Backtracking: `generate_permutations.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
92. Trie: `search word (exact match).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
93. Math: `sieve_of_eratosthenes (primes up to n).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
94. Graph: `define using adjacency list (dict of lists).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
95. Backtracking: `generate_combinations (n choose k).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
96. Arrays: `max_subarray_sum (Kadane).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
97. Recursion: `fibonacci_recursive(n) (naive recursive, stepping stone to DP).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
98. Recursion: `fibonacci_memo(n) (memoized recursive, stepping stone to DP).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
99. DP (1D): `fibonacci (tabulation).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
100. DP (1D): `climbing_stairs (n steps, 1 or 2 at a time).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
101. Trees (binary): `contains(value).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
102. Sliding window: `longest_substring_without_repeating.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
103. Trees (binary): `min.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
104. Trees (binary): `max.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
105. Bits: `get_bit, set_bit, clear_bit (bit manipulation basics).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
106. Heap (max): `convert min-heap implementation to max-heap.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
107. Trie: `starts_with (prefix check).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
108. Sliding window: `minimum_window_substring.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
109. Graph: `add_edge (directed and undirected variants).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
110. Trees (binary): `sum.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
111. Trees (binary): `average.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
112. Trees (binary): `count_of(n).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
113. Heap: `kth_largest element in array.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
114. DP (1D): `house_robber (non-adjacent elements max sum).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
115. Greedy: `jump_game (can reach last index?).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
116. Trie: `count_words_with_prefix.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
117. Graph: `has_edge and neighbors.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
118. Backtracking: `generate_parentheses (n pairs).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
119. DP (1D): `min_cost_climbing_stairs.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
120. Greedy: `jump_game_2 (min jumps to reach end).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
121. Trees (BST): `insert.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
122. Trees (BST): `search.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
123. Heap: `kth_smallest element in array.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
124. DP (1D): `coin_change (min coins to make amount).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
125. Trie: `delete word.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
126. Graph: `DFS traversal (iterative with stack).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
127. Union-Find: `basic implementation with find and union.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
128. DP (1D): `coin_change_2 (count ways to make amount).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
129. Union-Find: `add path compression.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
130. Trees (BST): `delete.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
131. Union-Find: `add union by rank.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
132. Trees (BST): `validate_bst.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
133. Greedy: `merge_intervals.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
134. Heap: `merge two heaps.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
135. Heap: `merge_k_sorted_lists (merge k sorted lists using heap).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
136. Trie: `autocomplete (return all words with given prefix).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
137. DP (1D): `longest_increasing_subsequence.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
138. Graph: `BFS traversal (iterative with queue).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
139. Greedy: `insert_interval.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
140. Arrays: `longest_consecutive_sequence.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
141. Binary search: `search_rotated_sorted_array.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
142. DP (2D): `unique_paths (grid, only right/down moves).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
143. Backtracking: `n_queens.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
144. Trees (BST): `inorder_successor.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
145. Greedy: `meeting_rooms (can attend all?).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
146. Heap: `top_k_frequent elements.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
147. Binary search: `find_min_rotated_sorted_array.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
148. Union-Find: `count connected components.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
149. Graph: `is_connected (for undirected graph).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
150. Trees (BST): `lowest_common_ancestor.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
151. DP (2D): `unique_paths_with_obstacles.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
152. Trie: `count total words in trie.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
153. Graph: `detect_cycle (directed graph).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
154. Greedy: `meeting_rooms_2 (min rooms needed).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
155. DP (2D): `min_path_sum (grid).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
156. Union-Find: `detect cycle in undirected graph.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
157. Graph: `detect_cycle (undirected graph).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
158. Backtracking: `sudoku_solver.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
159. Trees (binary): `is_balanced.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
160. Monotonic stack: `daily_temperatures.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
161. Heap: `sliding window maximum.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
162. Monotonic stack: `largest_rectangle_histogram.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
163. Graph: `shortest_path (unweighted, BFS-based).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
164. DP (string): `longest_common_subsequence.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
165. String matching: `naive pattern search (brute force).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
166. Trees (binary): `is_symmetric.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
167. Trie: `longest_common_prefix of all words.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
168. Monotonic stack: `trapping_rain_water.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
169. DP (string): `longest_palindromic_substring.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
170. Binary search: `find_peak_element.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
171. Graph: `topological_sort (Kahn's algorithm).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
172. Greedy: `gas_station (circular tour).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
173. Graph: `topological_sort (DFS-based).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
174. String matching: `build KMP failure function.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
175. Trees (binary): `diameter.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
176. DP (string): `longest_palindromic_subsequence.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
177. String matching: `KMP search (using failure function).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
178. Graph: `count connected components.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
179. Greedy: `activity_selection (max non-overlapping).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
180. DP (string): `edit_distance (Levenshtein).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
181. Binary search: `koko_eating_bananas (search on answer).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
182. Trees (binary): `serialize and deserialize.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
183. DP (tree): `house_robber_3 (binary tree version).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
184. String matching: `Rabin-Karp (rolling hash).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
185. Graph: `bipartite_check.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
186. Backtracking: `word_search (find word in grid).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
187. DP (string): `word_break (can segment into dictionary words).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
188. Greedy: `fractional_knapsack.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
189. DP (tree): `max_path_sum (binary tree).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
190. Binary search: `capacity_to_ship_packages (search on answer).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
191. Graph: `shortest_path_weighted (Dijkstra).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
192. Bits: `subsets_using_bitmask (alternate to backtracking).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
193. DP (2D): `0_1_knapsack.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
194. Sorting: `counting_sort (for limited range integers).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
195. DP (interval): `partition_equal_subset_sum.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
196. Graph: `Kruskal's MST (using Union-Find).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
197. Graph: `all_pairs_shortest_path (Floyd-Warshall).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
198. Math: `fast_exponentiation (modular, log n).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
199. Sorting: `radix_sort (uses counting sort).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
200. DP (interval): `matrix_chain_multiplication.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
201. Graph: `Prim's MST.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
202. DP (interval): `burst_balloons.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
203. Backtracking: `combination_sum (reuse allowed).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
204. DP (bitmask): `travelling_salesman (small n).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
205. Backtracking: `combination_sum_2 (no reuse, handle duplicates).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
206. Conversions: `list -> linked list without reusing as_array.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
207. Conversions: `linked list -> list (as_array).` ğŸ[x] ğŸ¦€[ ] ğŸŸ¨[ ]
208. Conversions: `BST -> sorted array (inorder).` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
209. Conversions: `sorted array -> balanced BST.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
210. Conversions: `adjacency list -> adjacency matrix.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
211. Conversions: `adjacency matrix -> adjacency list.` ğŸ[ ] ğŸ¦€[ ] ğŸŸ¨[ ]
